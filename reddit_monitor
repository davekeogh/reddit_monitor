#!/usr/bin/env python

import sys
import os
import subprocess
import threading
import ConfigParser

import gtk

try:
    import glib
    TIMEOUT_ADD = glib.timeout_add
    IDLE_ADD = glib.idle_add
except ImportError:
    import gobject
    TIMEOUT_ADD = gobject.timeout_add
    IDLE_ADD = gobject.idle_add

# Needed to display notifications when a new message comes in.
# Without, the icon will just change.
try:
    import pynotify
except ImportError:
    pynotify = None

# We can display a custom tooltip if egg.trayicon is available.
# Install python-gnome2-extras to get it.
try:
    import egg.trayicon
except ImportError:
    egg = None

# Saving the password in a secure manner is possible if we have gnome-keyring.
try:
    import gnomekeyring as keyring
except ImportError:
    keyring = None

# Provides an easy API to play a sound; provided by python-gnome2.
try:
    import gnome
    import socket
except ImportError:
    gnome = None

import reddit


REDDIT_ICON             = 'reddit_trans.png'
NEW_MAIL_ICON           = 'new_mail_trans.png'
BUSY_ICON               = 'busy.gif'
DEFAULT_CHECK_INTERVAL  = 10 # Minutes
REDDIT_INBOX_USER_URL   = 'http://www.reddit.com/message/inbox'
NEW_MESSAGE_SOUND       = 'message-new-instant.wav'

# This will be set to True when the program is run, if xdg-open is found
# somewhere in the path.
XDG_OPEN                = False

# Same thing here:
UI_DEFINITION           = None


# TODO: Refactor this. One function can do the job of all of these:

def find_sounds_directory():
    '''Tries to find the folder containing our icons in all the usual places.
    The first place to be checked is the current working directory. If it's
    found we assume that we're debugging. If the file can't be found this
    function returns None.'''
    
    paths = os.environ['XDG_DATA_DIRS'].split(':')
    return_value = None
    
    # This is mostly so that debugging isn't a pain in the ass.
    local = os.path.join(os.getcwd(), 'sounds')
    
    if os.path.exists(os.path.join(local, NEW_MESSAGE_SOUND)):
        return local
    
    else:
        for path in paths:
            full_path = os.path.exists(path, NEW_MESSAGE_SOUND)
            
            if os.path.exists(path, NEW_MESSAGE_SOUND):
                return_value = full_path
                break
    
    return return_value


def find_icon_directory():
    '''Tries to find the folder containing our icons in all the usual places.
    The first place to be checked is the current working directory. If it's
    found we assume that we're debugging. If the file can't be found this
    function returns None.'''
    
    paths = os.environ['XDG_DATA_DIRS'].split(':')
    return_value = None
    count = 0
    
    # This is mostly so that debugging isn't a pain in the ass.
    local = os.path.join(os.getcwd(), 'icons')
    
    for icon in (REDDIT_ICON, NEW_MAIL_ICON, BUSY_ICON):
        if os.path.exists(os.path.join(local, icon)):
            count += 1
    
    if count == 3:
        return local
    
    else:
        for path in paths:
            count = 0
            for icon in (REDDIT_ICON, NEW_MAIL_ICON, BUSY_ICON):
                full_path = os.path.join(os.path.join(path, 'reddit_monitor/icons'), icon)
                
                if os.path.exists(full_path):
                    count += 1
            
            if count == 3:
                return_value = os.path.join(os.path.join(path, 'reddit_monitor/icons'))
                break
    
    return return_value


def find_ui_definition():
    '''Tries to find the XML GtkBuilder file in all the usual places. The first
    place to be checked is the current working directory. If it's found we
    assume that we're debugging. If the file can't be found this function
    returns None.'''
    
    paths = os.environ['XDG_DATA_DIRS'].split(':')
    return_value = None
    
    # This is mostly so that debugging isn't a pain in the ass.
    local = os.path.join(os.getcwd(), 'reddit_tray_icon.ui')
    
    if os.path.exists(local):
        return local
    
    else:
        for path in paths:
            full_path = os.path.join(path, 'reddit_monitor/reddit_tray_icon.ui')
            
            if os.path.exists(full_path):
                return_value = full_path
                break
    
    return return_value


def open_url(url):
    '''Tries to use the xdg-open utility to open a URL in your prefered web
    browser. If it's not installed we fallback on using the Python webbrowser
    module which may choose the wrong browser in some cases.'''
    
    if XDG_OPEN:
        subprocess.call(['xdg-open', url])
    else:
        webbrowser.open(url)


class Application(object):
    
    config_dialog = None
    tooltip = None
    tray_icon = None
    menu = None
    reddit = None
    worker = None
    timer = None
    notification = None
    
    config = None
    username = None
    mail = None
    karma = None
    comment_karma = None
    messages = None
    checking = False
    logged_in = False
    
    options = {
        'interval'                   : None,
        'notify'                     : None,
        'remember_username_password' : None,
        'login_automatically'        : None,
        'sound'                      : None
    }
    
    def __init__(self):
        self.config = self.load_config()
        self.reddit = reddit.Reddit()
        self.config_dialog = ConfigDialog(self, *self.check_keyring())
    
    def load_config(self):
        config_file = os.path.expanduser('~/.config/reddit_monitor')
        
        if not os.path.exists(config_file):
            return None
        else:
            parser = ConfigParser.SafeConfigParser()
            parser.read([config_file])
            return parser
    
    def save_config(self):
        config_file = os.path.expanduser('~/.config/reddit_monitor')
        
        if os.path.exists(config_file):
            os.remove(config_file)
        
        parser = ConfigParser.SafeConfigParser()
        parser.add_section('Reddit_Monitor')
        # TODO: Use a loop; it's less ugly.
        parser.set('Reddit_Monitor', 'interval', str(self.options['interval']))
        parser.set('Reddit_Monitor', 'notify', str(self.options['notify']))
        parser.set('Reddit_Monitor', 'remember_username_password', str(self.options['remember_username_password']))
        parser.set('Reddit_Monitor', 'login_automatically', str(self.options['login_automatically']))
        parser.set('Reddit_Monitor', 'sound', str(self.options['sound']))
        parser.write(open(config_file, 'w'))
    
    def check_keyring(self):
        try:
            creds = keyring.find_items_sync(keyring.ITEM_GENERIC_SECRET,
                                           {'app_ident' : 'Reddit Monitor'})
            
            # TODO: Provide a drop-down menu of all the available usernames.
            #       We're selecting the newest one out of laziness.
            return creds[0].attributes['username'], creds[0].secret
        except keyring.NoMatchError:
            return None, None
    
    def save_keyring(self, username, password):
        keyring.item_create_sync(keyring.get_default_keyring_sync(),
                                 keyring.ITEM_GENERIC_SECRET, 'Reddit Monitor',
                                 {
                                    'app_ident' : 'Reddit Monitor',
                                    'username'  : username,
                                 }, 
                                 password, True)
    
    def quit(self, widget):
        gtk.main_quit()
        sys.exit(0)
    
    def update(self, widget=None):
        if not self.checking:
            self.checking = True
            
            self.tray_icon.set_icon(BUSY_ICON)
            
            def check():
                # This is run in a new thread to avoid blocking the UI if
                # connecting to reddit takes a little while.
                
                self.karma, self.comment_karma = self.reddit.get_karma()
                self.messages = self.reddit.get_new_mail()
                if self.messages:
                    self.tray_icon.set_icon(NEW_MAIL_ICON)
                    self.show_notification()
                    self.play_sound()
                else:
                    self.tray_icon.set_icon(REDDIT_ICON)
                
                self.checking = False

            self.worker = threading.Thread(target=check)
            self.worker.start()
        
        return True
    
    def play_sound(self, file=None):
        if self.options['sound']:
            if file:
                gnome.sound_play(file)
            else:
                if NEW_MESSAGE_SOUND:
                    gnome.sound_play(NEW_MESSAGE_SOUND)
    
    def clear_messages(self, widget=None):
        self.messages = []
        self.tray_icon.set_icon(REDDIT_ICON)
    
    def go_to_inbox(self, widget):
        open_url(REDDIT_INBOX_USER_URL)
    
    def show_notification(self):
        if self.options['notify']:
            latest_message = self.messages[len(self.messages) - 1]
            
            notification_body = 'from <b>%s</b>\n\n%s' % (latest_message['author'], latest_message['body'])
            self.notification = pynotify.Notification(latest_message['subject'], notification_body)
            self.notification.add_action('home', 'Inbox', self.inbox_clicked)
            self.notification.set_icon_from_pixbuf(gtk.gdk.pixbuf_new_from_file(REDDIT_ICON))
            
            if latest_message['was_comment']:
                self.notification.add_action('context', 'Context', self.context_clicked, latest_message['context'])
            
            self.notification.show()
    
    def inbox_clicked(self, n, action):
        open_url(REDDIT_INBOX_USER_URL)
        self.clear_messages()
    
    def context_clicked(self, n, action, context):
        open_url('http://www.reddit.com' + context)
        self.clear_messages()


class SoundChooserButton(gtk.FileChooserButton):
    
    def __init__(self, file=None):
        # FIXME: There's a bug here that I just can't get to the bottom of. It
        #        could be in the GTK+ bindings themselves. If this is called
        #        with a file, then the file filter will not be selected. Not a
        #        huge deal but still annoying.
        
        gtk.FileChooserButton.__init__(self, title='Select Sound File')
        
        filter = gtk.FileFilter()
        filter.set_name('All files')
        filter.add_pattern('*')
        self.add_filter(filter)
        filter = gtk.FileFilter()
        filter.set_name('Sound Files (*.wav)')
        filter.add_pattern('*.wav')
        self.add_filter(filter)
        self.set_filter(filter)
        
        if file:
            self.set_filename(file)


class ConfigDialog(object):
    
    app = None
    widgets = None
    sound_chooser = None
    
    def __init__(self, parent, username=None, password=None):
        self.app = parent
        
        self.widgets = gtk.Builder()
        self.widgets.add_from_file(UI_DEFINITION)
        
        self.widgets.get_object('message_label').set_line_wrap(True)
        self.widgets.get_object('message_frame').hide()
        
        self.widgets.get_object('image').set_from_file(REDDIT_ICON)
        
        if not pynotify:
            self.widgets.get_object('notify_checkbutton').set_active(False)
            self.widgets.get_object('notify_checkbutton').hide()
        
        if not keyring:
            self.widgets.get_object('remember_checkbutton').set_active(False)
            self.widgets.get_object('remember_checkbutton').hide()
            self.widgets.get_object('auto_checkbutton').set_active(False)
            self.widgets.get_object('auto_checkbutton').hide()
        
        if username and password:
            self.widgets.get_object('username_entry').set_text(username)
            self.widgets.get_object('password_entry').set_text(password)
            self.widgets.get_object('ok_button').grab_focus()
        else:
            self.widgets.get_object('username_entry').grab_focus()
            self.widgets.get_object('ok_button').set_sensitive(False)
        
        if self.app.config:
            self.widgets.get_object('update_spinbutton').set_value(self.app.config.getint('Reddit_Monitor', 'interval') / 60000)
            self.widgets.get_object('notify_checkbutton').set_active(self.app.config.getboolean('Reddit_Monitor', 'notify'))
            self.widgets.get_object('remember_checkbutton').set_active(self.app.config.getboolean('Reddit_Monitor', 'remember_username_password'))
            self.widgets.get_object('sound_checkbutton').set_active(self.app.config.getboolean('Reddit_Monitor', 'sound'))
            self.widgets.get_object('auto_checkbutton').set_active(self.app.config.getboolean('Reddit_Monitor', 'login_automatically'))
        else:
            # Default values:
            self.widgets.get_object('update_spinbutton').set_value(DEFAULT_CHECK_INTERVAL)
            
            if pynotify:
                self.widgets.get_object('notify_checkbutton').set_active(True)
        
        if NEW_MESSAGE_SOUND:
            self.sound_chooser = SoundChooserButton(file=NEW_MESSAGE_SOUND)
        else:
            self.sound_chooser = SoundChooserButton()
        
        self.widgets.get_object('pack_filechooserbutton_here').pack_start(self.sound_chooser)
        self.widgets.get_object('pack_filechooserbutton_here').show_all()
        
        self.widgets.get_object('username_entry').set_activates_default(True)
        self.widgets.get_object('password_entry').set_activates_default(True)
        self.widgets.get_object('update_spinbutton').set_activates_default(True)
        
        self.widgets.get_object('window').set_default(self.widgets.get_object('ok_button'))
        self.widgets.get_object('window').show()
        
        signals = {
            'on_cancel_button_activate'         : self.cancel,
            'on_ok_button_activate'             : self.ok,
            'on_entry_changed'                  : self.entry_contents_changed,
            'on_remember_checkbutton_toggled'   : self.remember_toggled,
            'on_sound_checkbutton_toggled'      : self.sound_toggled,
        }
        self.widgets.connect_signals(signals)
        
        if username and password and self.app.config.getboolean('Reddit_Monitor', 'login_automatically'):
            # Log in automatically
            self.widgets.get_object('ok_button').clicked()
    
    def set_sensitive(self, bool):
        self.widgets.get_object('username_entry').set_sensitive(bool)
        self.widgets.get_object('password_entry').set_sensitive(bool)
        self.widgets.get_object('remember_checkbutton').set_sensitive(bool)
        self.widgets.get_object('auto_checkbutton').set_sensitive(bool)
        self.widgets.get_object('notify_checkbutton').set_sensitive(bool)
        self.widgets.get_object('sound_checkbutton').set_sensitive(bool)
        self.widgets.get_object('update_spinbutton').set_sensitive(bool)
        self.widgets.get_object('ok_button').set_sensitive(bool)
        self.widgets.get_object('label3').set_sensitive(bool)
        self.widgets.get_object('label4').set_sensitive(bool)
        self.sound_chooser.set_sensitive(bool)
        self.widgets.get_object('label6').set_sensitive(bool)
    
    def remember_toggled(self, widget):
        if widget.get_active():
            self.widgets.get_object('auto_checkbutton').set_sensitive(True)
        else:
            self.widgets.get_object('auto_checkbutton').set_sensitive(False)
            self.widgets.get_object('auto_checkbutton').set_active(False)
    
    def sound_toggled(self, widget):
        if widget.get_active():
            self.sound_chooser.set_sensitive(True)
            self.widgets.get_object('label6').set_sensitive(True)
        else:
            self.sound_chooser.set_sensitive(False)
            self.widgets.get_object('label6').set_sensitive(False)
    
    def entry_contents_changed(self, widget):
        if not len(self.widgets.get_object('username_entry').get_text()) >= 3 or not len(self.widgets.get_object('password_entry').get_text()) >= 3:
            self.widgets.get_object('ok_button').set_sensitive(False)
        else:
            self.widgets.get_object('ok_button').set_sensitive(True)
    
    def cancel(self, widget, event=None):
        gtk.main_quit()
        sys.exit(0)
    
    def ok(self, widget):
        if not self.app.checking:
            self.app.checking = True
            
            self.set_sensitive(False)
            
            self.widgets.get_object('message_frame').show()
            self.widgets.get_object('message_label').set_text('Logging in to reddit...')
            
            self.app.options['remember_username_password'] = self.widgets.get_object('remember_checkbutton').get_active()
            self.app.options['login_automatically'] = self.widgets.get_object('auto_checkbutton').get_active()
            self.app.options['notify'] = self.widgets.get_object('notify_checkbutton').get_active()
            self.app.options['sound'] = self.widgets.get_object('sound_checkbutton').get_active()
            self.app.options['interval'] = int(self.widgets.get_object('update_spinbutton').get_value()) * 60000
            
            def check_logged_in():
                if self.app.logged_in:
                    self.app.tray_icon = TrayIcon(self.app)
                    self.widgets.get_object('window').hide()
                    self.app.timer = TIMEOUT_ADD(self.app.options['interval'], self.app.update)
                    return False
                else:
                    return True
            
            IDLE_ADD(check_logged_in)
            
            def login(username, password):
                # This is run in a new thread to avoid blocking the UI if
                # connecting to reddit takes a little while.
                
                self.app.logged_in = False
                
                try:
                    self.app.reddit.login(username, password)
                    self.widgets.get_object('message_label').set_text('Fetching karma scores...')
                    self.app.karma, self.app.comment_karma = self.app.reddit.get_karma()
                    self.widgets.get_object('message_label').set_text('Checking for new messages...')
                    self.app.messages = self.app.reddit.get_new_mail()
                    self.app.username = username
                    self.widgets.get_object('message_label').set_markup('Logged in to reddit as <i>%s</i>.' % self.app.username)
                    
                    if self.app.config.getboolean('Reddit_Monitor', 'remember_username_password'):
                        self.app.save_keyring(username, password)
                    self.app.save_config()
                    
                    self.app.logged_in = True
                except reddit.RedditInvalidUsernamePasswordException, e:
                    self.widgets.get_object('message_label').set_text(e.args[0])
                    self.set_sensitive(True)
                    self.widgets.get_object('username_entry').grab_focus()
                    
                    self.app.logged_in = False
                finally:
                    self.app.checking = False
                    
            self.app.worker = threading.Thread(target=login, args=(self.widgets.get_object('username_entry').get_text(), self.widgets.get_object('password_entry').get_text()))
            self.app.worker.start()


def TrayIcon(app):
    if app.messages:
        app.play_sound()
        app.show_notification()
    
    if egg:
        from reddit.egg_tray_icon import EggTrayIcon
        global REDDIT_ICON, NEW_MAIL_ICON
        return EggTrayIcon(app, PopupMenu(app), REDDIT_ICON, NEW_MAIL_ICON)
    else:
        return GtkTrayIcon(app)


class GtkTrayIcon(gtk.StatusIcon):
    
    app = None
    menu = None
    
    def __init__(self, parent):
        gtk.StatusIcon.__init__(self)
        
        self.app = parent
        self.menu = PopupMenu(parent)
        
        self.connect('popup-menu', self.menu.popup)
        
        if self.app.messages:
            self.set_from_pixbuf(gtk.gdk.pixbuf_new_from_file(NEW_MAIL_ICON))
            self.menu.ui_manager.get_widget('/TrayMenu/Reset').set_sensitive(True)
            
            if len(self.app.messages) == 1:
                messages_string = 'New messages: 1'
            else:
                messages_string = 'New messages: %d' % len(self.app.messages)
        else:
            self.set_from_pixbuf(gtk.gdk.pixbuf_new_from_file(REDDIT_ICON))
            self.menu.ui_manager.get_widget('/TrayMenu/Reset').set_sensitive(False)
            messages_string = 'New messages: 0'
        
        tooltip_string = '%s\nKarma: %d\nComment karma: %d\n%s' % (self.app.username, self.app.karma, self.app.comment_karma, messages_string)
        self.set_tooltip(tooltip_string)
        
        self.set_visible(True)
    
    def set_icon(self, path):
        self.set_from_pixbuf(gtk.gdk.pixbuf_new_from_file(path))


class PopupMenu(object):
    
    app = None
    ui_manager = None
    action_group = None
    
    def __init__(self, parent):
        self.app = parent
        
        actions = [
            ('Inbox', gtk.STOCK_HOME, 'Go to inbox', None, None, self.app.go_to_inbox),
            ('Refresh', gtk.STOCK_REFRESH, 'Check for messages', None, None, self.app.update),
            ('Reset', gtk.STOCK_CLEAR, 'Mark as read', None, None, self.app.clear_messages),
            ('Quit', gtk.STOCK_QUIT, None, None, None, self.app.quit)
        ]
        
        self.action_group = gtk.ActionGroup('Reddit Monitor')
        self.action_group.add_actions(actions)
        
        ui = """
            <ui>
                <popup name='TrayMenu'>
                    <menuitem action='Inbox' />
                    <separator/>
                    <menuitem action='Refresh' />
                    <menuitem action='Reset' />
                    <separator/>
                    <menuitem action='Quit' />
                </popup>
            </ui>
        """
        
        self.ui_manager = gtk.UIManager()
        self.ui_manager.insert_action_group(self.action_group, 0)
        self.ui_manager.add_ui_from_string(ui)
    
    def popup(self, widget, button, activate_time, data=None):
        self.ui_manager.get_widget('/TrayMenu').popup(None, None, None, button, activate_time)


def main(args):
    if gtk.check_version(2, 12, 0):
        # This will return None if you have GTK+ version 2.12 or higher. It will
        # return a less useful error string than the one we're going to display
        # below otherwise.
        print 'Reddit Monitor requires GTK+ (and it\'s Python bindings) version 2.12 or higher.'
        sys.exit(1)
    
    # We can't do anything if we can't find this file obviously.
    ui = find_ui_definition()
    if not ui:
        print 'Unable to find the UI definition XML file. Reddit Monitor may be installed incorrectly.'
        sys.exit(1)
    else:
        global UI_DEFINITION
        UI_DEFINITION = ui
    
    # We need the icons too.
    icons = find_icon_directory()
    if not icons:
        print 'Unable to find the icons. Reddit Monitor may be installed incorrectly.'
        sys.exit(1)
    else:
        global REDDIT_ICON, NEW_MAIL_ICON, BUSY_ICON
        REDDIT_ICON = os.path.join(icons, REDDIT_ICON)
        NEW_MAIL_ICON = os.path.join(icons, NEW_MAIL_ICON)
        BUSY_ICON = os.path.join(icons, BUSY_ICON)
    
    # Check to see if we have xdg-open.
    for path in os.environ.get('PATH').split(':'):
        if os.path.exists(os.path.join(path, 'xdg-open')):
            global XDG_OPEN
            XDG_OPEN = True
    
    if not XDG_OPEN:
        import webbrowser
    
    # See if everything is in order to play some sounds:
    if gnome:
        gnome.sound_init(socket.gethostname())
        
        sounds = find_sounds_directory()
        global NEW_MESSAGE_SOUND
        
        if sounds:
            NEW_MESSAGE_SOUND = os.path.join(sounds, NEW_MESSAGE_SOUND)
        else:
            NEW_MESSAGE_SOUND = None
    
    if pynotify:
        pynotify.init('Reddit Monitor')
    
    gtk.gdk.threads_init()
    
    app = Application()
    gtk.main()


if __name__ == '__main__':
    main(sys.argv)
